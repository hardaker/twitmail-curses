#!/usr/bin/perl

use Net::Twitter;
use Data::Dumper;
use Text::Wrap;
use Getopt::GUI::Long;
use strict;
use Date::Parse;

our $VERSION = "0.1";

Getopt::GUI::Long::Configure(qw(display_help no_ignore_case allow_zero));

my %opts = (m => 'replies,friends');

GetOptions(\%opts,
	   ["a|show-all", "Show all messages, not just recent"],
	   ["m|modes=s",  "Comma separated modes to use: replies,friends"],
	   ["u|update",   "Set your status from arguments"],
	   ["r|reply=i",  "Reply to message number INTEGER with text from arguments"],
	   ["f|follow=s", "Follow the user named STRING"],
	   ["S|no-save",  "Don't save the config file back"],
	   ["n|count=i",  "Number of messages to return (max)"],
	   ["d|dump",     "Dumper the results instead of nicely printing"],
	  );

my %config;

read_config();

my $twit = Net::Twitter->new(username => $config{'user'},
			     password => $config{'password'},
			     source => 'twitmail');

#$twit->credentials($config{'user'}, $config{'password'});

# set our update status
if ($opts{'u'}) {
    $twit->update({status => format_message()});
}

# reply
if ($opts{'r'}) {
    $opts{'r'} = sprintf("%02.2d", $opts{'r'});
    if (!exists($config{'msgnum' . $opts{'r'}})) {
	die "No such message number: $opts{'r'}\n";
    }
    $twit->update({status =>
		   format_message('@' . $config{'usernum' . $opts{'r'}}),
		   in_reply_to_status_id => $config{'msgnum' . $opts{'r'}}});
    exit;
}

# add a friend if needed
if ($opts{'f'}) {
    $twit->create_friend({id => $opts{'f'}, follow => '1'});
}

# display mail
my @modes = split(/\s*,\s*/,$opts{'m'});

my $msgnum = 0;

foreach my $mode (@modes) {

    my %args;
    if (!$opts{'a'} && defined($config{$mode . '_since_id'})) {
	$args{'since_id'} = $config{$mode . '_since_id'};
    }

    if ($opts{'n'}) {
	$args{'count'} = $opts{'n'};
    }

    if ($mode eq 'replies') {
	print_results($twit->replies(\%args), $mode, 'since_id', 'id');
    }

    if ($mode eq 'friends') {
	print_results($twit->friends_timeline(\%args), $mode, 'since_id', 'id');
    }

    if ($mode eq 'public') {
	print_results($twit->public_timeline(\%args), $mode);
    }
}

save_config();

sub print_results {
    my ($data, $mode, $setarg, $setfrom) = @_;

    if ($opts{'d'}) {
	print Dumper($_[0]);
	return;
    }

    if ($twit->http_message() ne 'OK') {
	print "ERROR!\n";
	print "  ", $twit->http_code(),"\n";
	print "  ", $twit->http_message(),"\n";
	print "  ", $twit->get_error()->{'error'},"\n";
	exit(1);
    }

    return if ($#$data == -1);

    print "---- $mode ------------------------------------------------------------\n";

    my $lastday = "";
    my $lastuser = "";
    foreach my $dat (reverse @$data) {

	$msgnum++;

	# set the time stamp from zulu time to localtime
	$dat->{'created_at'} = localtime(str2time($dat->{'created_at'}));

	# truncate for prettiness
	$dat->{'created_at'} =~ s/^(...)......./$1/; # only use day of week
	my $thisday = $1;
	$dat->{'created_at'} =~ s/:\d\d//;           # drop seconds
	$dat->{'created_at'} =~ s/^$lastday/   / if ($lastday);
	$lastday = $thisday;

	# print the results
	print wrap(sprintf("%2.2d %-9.9s %-10.10s ", $msgnum,
			   $dat->{'created_at'},
			   ($lastuser eq $dat->{'user'}{'screen_name'})
			   ? "" : $dat->{'user'}{'screen_name'}),
		   sprintf("%2.2s %-9.9s %-10.10s ","", "",""),
		   $dat->{'text'}),"\n";
	$lastuser = $dat->{'user'}{'screen_name'};

	my $formattednum = sprintf("%02.2d", $msgnum);

	$config{'msgnum' . $formattednum} = 
	  $dat->{'id'} if (exists($dat->{'id'}));
	$config{'usernum' . $formattednum} =
	  $dat->{'user'}{'screen_name'} if (exists($dat->{'user'}));
    }

#    print "  ", Dumper($twit->get_error()),"\n";

    # XXX: only if error
    if (defined($mode) && defined($setarg)) {
	$config{"${mode}_${setarg}"} = $data->[0]{$setfrom || $setarg};
    }
}

sub read_config {
    open(I, $ENV{'HOME'} . "/.twitmailrc");
    while (<I>) {
	my @data = /^([^\s]+)\s+(.*)/;
	$config{$data[0]} = $data[1];
    }
}

sub save_config {
    return if ($opts{'S'});
    open(O, ">" . $ENV{'HOME'} . "/.twitmailrc");
    foreach my $key (sort keys(%config)) {
	print O "$key\t$config{$key}\n";
    }
}

sub format_message {
    my $output;
    $output .= join(" ",@_, @ARGV);
    if (length($output) > 140) {
	die "message too long (" . length($output) . " > 140); sorry\n";
    }
    return $output;
}

=pod

=head1 NAME

twitmail - Because some tweets you just can't afford to miss

=head1 SYNOPSIS

Read new twits:

  # twitmail
  ---- friends ---------------------------------------------------------
  01 Tue 18:33 airsax     woohoo finally my DSP board plays nice with my
                          macbook!!!  i've spent on and off the last 3
                          or 4 weeks working on this!
  02     18:38 canusis    how does it always get to be 7pm, and I haven't
                          even gotten started on any work yet?
                          tomorrow won't be any better, meetings from
                          11-5.
  03     19:10 andrewsf   After 4 crashes in 5 minutes, I'm wondering if
                          paper would be a more productive
                          alterrnative to Microsoft Word.

Update your status:

  # twitmail -u is writing documentation for twitmail

Reply to an existing post (#3 ... @NAME is auto-added):

  # twitmail -r 3 Maybe you should write your paper in tweets

Check for new updates (note how replies to me (@hardaker) are singled out):

  # twitmail
  ---- replies ------------------------------------------------------
  01 Tue 20:13 jasonsalas @hardaker here's that @metajack post about
                          bot design...good stuff!    http://is.gd/bzDV
  ---- friends ------------------------------------------------------
  02 Tue 20:24 hardaker   @andrewsf Maybe you should write your paper
                          in tweets


=head1 DESCRIPTION

B<twitmail> was designed as a command-line client to keep track of
tweets that have occured.  Yes, I have fancy graphical clients to do
that too.  But, most of them don't easily show replies to my previous
mesasges without scrolling back a ways.  Especially when I've been
gone for 3 days.  So, twitmail was designed to accomodate that need
and just print a quick summary of tweets that have arrived.

By default, running twitmail without arguments checks for both replies
and friend updates.

=head1 CONFIGURATION

You need to put the following two lines in a ~/.twitmailrc file:

  user     TWITER-USER-NAME
  password TWITTER-PASSWORD

=head1 OPTIONS

=over

=item -a

Shows all messages, not just the most recent.

=item -m MODES

B<MODES> is a comma separated list of things to show:

=over

=item replies

Replies sent to you

=item friends

Updates from friends

=item public

Show updates from all the world.

=back

The default value is replies,friends

=item -u MESSAGE

Updates your twitter status to B<MESSAGE>

=item -r NUM MESSAGE

Replies to a particular message B<NUM>.  A I<@user> prefix will automatically
be added so all you need is the message number (the left most column
in the output).

=item -f USER

Follows a particular B<USER>.  Doesn't seem to work yet.

=item -S

Tells twitmail not to save the configuration again.  In particular,
this means that it will not remember you've just read the messages
you've read and you'll see them again next time.

=item -n COUNT

Only displays B<COUNT> messages.

(has an issue with some modes)

=back

=head1 TODO

Things on the todo list:

=over

=item -

Make replies indented and next to other messages

=item -

Detect that not enough messages could be retrieved and realize you skipped some.

=back

=cut

